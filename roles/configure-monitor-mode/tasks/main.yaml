# WHY?
# If this is first boot, this file will not exist.
# We will want to reboot after writing this file, as it guarantees the wifi 
# adapter mapping. So, we check, run our code, and at the end of this set of
# plays, we reboot if the file was *not* present.
- name: find out if the rules exist already (is this first boot?)
  ansible.builtin.stat:
    path: "{{ persistent_rules }}"
  register: rules_file

- name: install find-ralink tool binary
  ansible.builtin.get_url:
    url: "{{ findralink.binary_url }}"
    dest: "{{ findralink.install_path }}"
    owner: root
    group: root
    mode: 0755
  become: yes

# find-ralink options for -descriptor
# exists bool
# physicalId    int
# description   string
# busInfo       string
# logicalName   string
# serial        string
# mac           string
# configuration string

# We must "become" for the find-ralink tool.
# It will not find USB devices as non-root.
# Normally, if no device is found, there is a non-zero error.
# However, if we're asking nicely to find out if one exists,
# we will get "true" or "false", and a 0 error code always.
# (Short of catestrophic errors/failures.)
- name: do we find an ralink adapter?
  ansible.builtin.command:
    cmd: "{{ findralink.bin }} --discover --exists"
  register: ralink_exists
  become: yes

# - name: what is going on
#   ansible.builtin.debug:
#     msg: "{{ ralink_exists }}"

# - name: what is going on also
#   ansible.builtin.debug:
#     msg: "{{ ralink_exists.stdout }}"

- name: get the mac address if it exists
  ansible.builtin.command:
    cmd: "{{ findralink.bin }} --discover --extract mac"
  register: ralink_mac
  become: yes
  when: "'true' in ralink_exists.stdout"

# If we find an adapter, then we can proceed to update 
# some global config files. 
- name: write wlan1 into udev rules
  ansible.builtin.lineinfile:
    path: "{{ persistent_rules }}"
    state: present
    line: 'SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="{{ ralink_mac.stdout }}", NAME="wlan1"'
    create: true
  become: yes
  when: "'true' in ralink_exists.stdout"

- name: do we find the default broadcom adapter?
  ansible.builtin.command:
    cmd: "{{ findralink.bin }} --search brc --field configuration --exists"
  register: brc_exists
  become: yes

- name: get the mac address of the broadcom adapter if it exists
  ansible.builtin.command:
    cmd: "{{ findralink.bin }} --search brc --field configuration --extract mac"
  register: brc_mac
  become: yes
  when: "'true' in brc_exists.stdout"

- name: write wlan0 into udev rules
  ansible.builtin.lineinfile:
    path: "{{ persistent_rules }}"
    state: present
    line: 'SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="{{ brc_mac.stdout }}", NAME="wlan0"'
  become: yes
  when: "'true' in brc_exists.stdout"

## REBOOT
# If we just wrote the persistent rules for the first time, we should reboot. 
# Next time, we won't reboot. Or, that's the theory.
- name: first-time reboot
  ansible.builtin.reboot:
  when: not rules_file.stat.exists
  become: yes

# Take the interface down, set it in monitor mode, and 
# then bring it back up.
- name: take down wlan1
  ansible.builtin.command:
    cmd: ip link set wlan1 down
  become: yes

- name: set wlan1 into monitor mode
  ansible.builtin.command:
    cmd: iw wlan1 set monitor none
  become: yes

- name: bring up down wlan1
  ansible.builtin.command:
    cmd: ip link set wlan1 up
  become: yes
